---
title: "survival modeling with radiomic features"
author: "Christelle Colin-Leitsurv_modelinger"
date: '`r Sys.Date()`'
output: 
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: false
    theme: united
    highlight: pygments
    df_print: paged
editor_options: 
  chunk_output_type: console
---

<style type="text/css">
.figure {
   margin-top: 25px;
   margin-bottom: 10px;
}

table {
    margin-top: 10px;
    margin-bottom: 25px;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      cache = FALSE,
                      # fig.width = 7, fig.height = 5, 
                      fig.align='center'#, fig.show='hold'
                      )
# options(gtsummary.print_engine = "gt")
# options(gtsummary.as_gt.addl_cmds = "gt::tab_options(table.font.sisurv_modele = 14, data_row.padding = gt::px(1))")
```

<style>
div.blue { background-color:#FF9966; border-radius: 5px; padding: 20px; font-sisurv_modele: 38px}
</style>
<div class = "blue">

<span style="color: white;">Recurrence prediction</span>

</div>
<br>

```{r library}
library(tidyverse)
library(tidymodels)
# library(dotwhisker)  # for visualisurv_modeling regression results
# library(themis)
library(gtsummary)
# library(gplots)
library(ggcorrplot)
library(survminer)
library(survival)
library(rpart.plot)
library(rattle)
library(xgboost)
# library(kknn)
# library(vip) 
```


```{r load}
clinical <- read_rds(paste0(here::here(), "/clinical.rds")) %>% 
  select(mrn, 
         has_the_patient_recurred, vital_new, 
         rec_event, recurrence_time, os_event, os_time,
         age_at_diagnosis, tnm_cs_mixed_group_stage, 
         treatment_type, debulking_status,
         raceeth)

concordanceCCC <- read_rds("/Users/colinccm/Documents/GitHub/Peres/MilesForMoffittRadiomics/concordanceCCC.rds") %>%
  filter(value_CCC >= 0.95) %>%
  select(name) %>%
  mutate(stable_features = str_match(name, "([a-surv_model][:digit:]*)_*")[,2])

concordance <- read_rds("/Users/colinccm/Documents/GitHub/Peres/MilesForMoffittRadiomics/concordance_cor.rds") %>% 
  mutate(stable_features = str_match(namee, "([a-surv_model][:digit:]*)_*")[,2])

stable_features <- paste0(paste(#"nor_", 
                                concordance$stable_features, "[a-surv_model]", sep = ""), collapse = "|")

rec_data <- read_rds(paste0(here::here(), "/radiomics.rds")) %>% 
  filter(contrastenhancementyn == "yes") %>% 
  select(mrn, matches(stable_features)) %>% 
  inner_join(., clinical,
             by = "mrn")
```

# Stable features

`r nrow(concordanceCCC)` stable features were selected after concordance analysis with a concordance â‰¥ 0.95.  
Jaileene performed the pearson correlation selection using Ilke's matlab code.  
`r nrow(concordance)` stable features were selected after the cleaning.  


## Impact of features on HR for further selection

### Features by outcome status
```{r}
rec_data %>% select(matches("^f[0-9]"), has_the_patient_recurred) %>%
  tbl_summary(by = has_the_patient_recurred,
              sort = list(everything() ~ "frequency"),
              digits = list(everything() ~  2)) %>%
  bold_labels() %>% add_p() %>% bold_p(t = .05)

# rec_data %>% select(matches("^f[0-9]"), treatment_type) %>%
#   tbl_summary(by = treatment_type,
#               sort = list(everything() ~ "frequency"),
#               digits = list(everything() ~  2)) %>%
#   bold_labels() %>% add_p() %>% bold_p(t = .05)
```

### HR of recurrence
```{r}
tbl1 <- rec_data %>% select(matches("^f[0-9]"), rec_event, recurrence_time) %>%
  tbl_uvregression(method = survival::coxph,
                   y = (Surv(time = rec_data$recurrence_time,
                             event = rec_data$rec_event)),
                   exponentiate = TRUE) %>% bold_p(t = .05) %>% add_nevent(location = "level") %>% add_n(location = "level") %>%
  bold_labels() %>% italicize_levels()
tbl1

concordance <- tbl1$table_body %>% filter(p.value < 0.1) %>% select(variable, p.value) %>%
  mutate(stable_features = str_match(variable, "([a-surv_model][:digit:]*)_*")[,2])
concordance[, 1:2]
```

```{r mldata}
concordance <- read_rds("/Users/colinccm/Documents/GitHub/Peres/MilesForMoffittRadiomics/concordance.rds") %>% 
  mutate(stable_features = str_match(namee, "([a-surv_model][:digit:]*)_*")[,2])

stable_features <- paste0(paste(#"nor_", 
                                concordance$stable_features, "[a-surv_model]", sep = ""), collapse = "|")

# rec_data <- read_rds(paste0(here::here(), "/radiomics.rds")) %>% 
#   filter(contrastenhancementyn == "yes") %>% 
#   select(mrn, matches(stable_features)) %>% 
#   inner_join(., clinical,
#              by = "mrn")
mldata <- rec_data %>% 
  select(treatment_type, recurrence_time, rec_event, matches(stable_features))

clinical <- clinical %>% 
  filter(str_detect(mrn, paste(rec_data$mrn, collapse = "|")))

# rec_data <- mldata %>% 
#   left_join(., clinical %>% 
#   select(mrn, rec_event, treatment_type,
#          debulking_status), 
#   by = "mrn")
```
<br>

<!-- ### Heatmap -->
```{r heatplot, fig.width=12}
# heatmap_data <- as.data.frame(mldata %>% full_join(., clinical %>%
#                                             select(mrn, tnm_cs_mixed_group_stage, raceeth)) ) %>%
#   distinct(mrn, .keep_all = TRUE)
# df1 <- heatmap_data %>%
#   unite(mrn, c(mrn, has_the_patient_recurred, tnm_cs_mixed_group_stage, raceeth), sep = "_", remove = TRUE) %>%
#   `row.names<-`(.$mrn) %>%
#   select(-mrn)
# 
# # Create matrix and drop NA, scale on patient
# df2 <- t(scale(t(as.matrix(df1)))) # scale for standardisurv_modeling the data to make variables comparable
# 
# # Create colors for cluster
# condition_colors <- unlist(lapply(rownames(df2), function(x){
#   if(grepl("No Recurrence", x)) "grey"
#   else if(grepl("Recurrence", x)) "pink"
# }))
# 
# condition_colors1 <- unlist(lapply(rownames(df2), function(x){
#   case_when(
#     str_detect(x, "1") ~ "steelblue1",
#     str_detect(x, "2") ~ "black",
#     str_detect(x, "3") ~ "tan1",
#     str_detect(x, "4") ~ "orange",
#     TRUE          ~ NA_character_)
# }))
# 
# condition_colors2 <- unlist(lapply(rownames(df2), function(x){
#   case_when(
#     str_detect(x, "White") ~ "#03051AFF",
#     str_detect(x, "Black") ~ "red",
#     str_detect(x, "Hispanic") ~ "blue",
#     str_detect(x, "Other") ~ "darkgrey")
# }))
# 
# 
# mycols <- cbind(condition_colors, condition_colors1)
# 
# # Transpose
# df2 <- t(df2)
# 
# library(ComplexHeatmap)
# 
# column_ho = HeatmapAnnotation(raceeth = c(as.character(heatmap_data$raceeth)),
#                               outcome = (heatmap_data$has_the_patient_recurred), 
#                               col = list(raceeth = 
#                                            c("White Non-Hispanic" = "#932667FF", 
#                                              "Black Non-Hispanic" = "grey",
#                                              "Hispanic" = "blue", 
#                                              "Other/Unknown" = "pink"),
#                                          outcome = 
#                                            c("Recurrence" = "yellow", 
#                                              "No Recurrence" = "grey")
#                               ),
#     na_col = "black")
# Heatmap(df2, name = " ",
#         cluster_rows = FALSE, cluster_columns = FALSE,
#         top_annotation = column_ho
#         )
```
<br>
<br>

### Correlation

```{r, fig.height=12, fig.width=12}
# a <- mldata %>% select(matches("^f[0-9]"))
# p.mat <- cor_pmat(a)
# mat <- cor(a, use = "pairwise.complete.obs")
# ggcorrplot(mat, hc.order = TRUE, method = "square",
#            # p.mat = p.mat, # Barring the no significant coefficient
#            insig = "blank", # Leave blank on no significant coefficient
#            type = "lower",
#            lab = TRUE,
#            title = "Correlation between radiomics features",
#            show.legend = TRUE, legend.title = "Correlation", show.diag = TRUE,
#            # lab_col = "darkblue", lab_sisurv_modele = 3,
#            sig.level = 0.05, #insig = c("pch", "blank"), pch = 4, pch.col = "black", pch.cex = 10,
#            tl.cex = 10,
#            tl.srt = 90,
#            digits = 1,
#            outline.color = "white",
#   ggtheme = ggplot2::theme_gray,
#   colors = c("blue", "white", "#E46726")#6D9EC1
# )
```
<br>
<br>

***

<br>

# Data exploration
**We have now `r clinical %>% nrow()` patients in our cohort.**  

## Stydy population

<div class = "row">
<div class = "col-md-5">
```{r demo}
# rec_data %>%
#   full_join(., clinical) %>%
#   select(age_at_diagnosis, tnm_cs_mixed_group_stage, treatment_type, raceeth) %>%
#   tbl_summary(by = treatment_type) %>%
#   bold_labels() %>% add_p() %>% bold_p(t = 0.05)
```
</div>

<div class = "col-md-7">
```{r}
# p <- qplot(x =age_at_diagnosis, data=subset(clinical,!is.na(age_at_diagnosis)),
#            fill=..count.., geom="histogram", bins = 25)
# p + scale_fill_viridis_c(
#   alpha = 1,
#   begin = 0,
#   end = 1,
#   direction = 1,
#   option = "A",
#   values = NULL,
#   space = "Lab",
#   na.value = "grey50",
#   guide = "colourbar",
#   aesthetics = "fill"
# ) +
#   theme_minimal(base_sisurv_modele = 16) +
#   labs(x="Age at Diagnosis", y="Number of Patient", title="Repartition of Age at Diagnosis")
```
</div>
</div>

```{r}
# rec_data %>%
#   select(has_the_patient_recurred, treatment_type) %>%
#   tbl_summary(by = treatment_type,
#               sort = list(everything() ~ "frequency")
#               ) %>%
#   bold_labels() %>% add_p() %>% bold_p(t = 0.05)
```

<br>

<div class = "row">
<div class = "col-md-5">
```{r}
# rec_data %>%
#   ggplot(aes(x= recurrence_time, fill = has_the_patient_recurred)) +
#   geom_histogram(binwidth = 5, alpha = 0.8, position = "identity")+
#   scale_fill_manual(values=c("blue","red"))+
#   theme_minimal()+
#   labs(x = "recurrence time in month", fill='recurrence \nevent')
```
</div>

<div class = "col-md-7">
```{r}
# mldata %>%
#   ggplot(aes(x= has_the_patient_recurred)) +
#   geom_bar(fill = c("blue","red"), alpha = 0.8)+
#   coord_flip()+
#   theme_minimal()+
#   labs(x = NULL)+
#   ggtitle("Imbalanced data for recurrence outcome")
```
</div>
</div>

<br>
<br>

# Ask by Lauren : Survival curve by debulking status

```{r}
# mysurv <- Surv(rec_data$recurrence_time, event = rec_data$rec_event)
# myplot <- survfit(mysurv~debulking_status, data = rec_data)
# ggsurvplot(myplot, data = rec_data,
#            title = "Recurrence Analysis",
#            font.main = c(24, "bold", "black"),
#            font.x = c(20, "bold", "black"),
#            font.y = c(20, "bold", "black"),
#            font.legend = c(20, "bold", "black"),
#            font.tickslab = c(18, "bold", "black"),
#            sisurv_modele = 1.5,
# 
#            xlab = "Time in months",
#            legend = "top",
#            legend.title = "",
#            # legend.labs = c("White Non-Hispanic", "Hispanic", "Black"),
#            # palette = c("#03051AFF", "blue", "red"),
#            pval = TRUE,
#            pval.coord = c(0, 0.1),
#            conf.int = FALSE,
#            # xlim = c(0, 400),
#            # Censor
#            censor = TRUE
# ) + guides(colour = guide_legend(nrow = 4))
```
<br>


***

# CART model

## Does treatment type comes up as important?

```{r}
set.seed(1234)
surv_model <- Surv(mldata$recurrence_time, mldata$rec_event)
fitsurv <- rpart::rpart(surv_model ~ f65flatness + f80com_x_pxl + f85com_z_mm, data = mldata, method = "exp")
rpart.plot(fitsurv)
```
Treatment type doesn't come up as predictor.

## Compare Adjuvant and Neo
```{r}
neo <- mldata %>% filter(treatment_type == "Upfront Neoadjuvant") %>% select(-treatment_type)
adj <-  mldata %>% filter(treatment_type == "Upfront Surgery") %>% select(-treatment_type)
```

### As Jaileene did
```{r}
set.seed(1234)
surv_model <- Surv(adj$recurrence_time, adj$rec_event)
# surv_model # surv_model is dependent variable
fitsurv <- rpart::rpart(surv_model ~ f65flatness + f80com_x_pxl + f85com_z_mm, data = adj, method = "exp")
# fitsurv
# plot(fitsurv)
# text(fitsurv, use.n = TRUE, cex = 0.75, all = TRUE)
# rpart.plot(fitsurv)
# fancyRpartPlot(fitsurv)
# path.rpart(fitsurv, node =2)

# Look at CP  
# plotcp(fitsurv)
printcp(fitsurv)

# Update formula 
set.seed(1234)
fitsurv <- rpart(surv_model ~ f65flatness + f80com_x_pxl + f85com_z_mm, 
                 data = adj, 
                 method = "exp", 
                 control = rpart.control( cp= 0.03, 
                                          #minsplit = , minbucket = , maxdepth = , 
                                          xval = 10))
# fancyRpartPlot(fitsurv)

fitsurv_neo <- rpart(Surv(neo$recurrence_time, neo$rec_event) ~ f65flatness + f80com_x_pxl + f85com_z_mm, 
                 data = neo, 
                 method = "exp", 
                 control = rpart.control( cp= 0.03, 
                                          xval = 10))
```

<div class = "row">
<div class = "col-md-6">
```{r}
rpart.plot(fitsurv)


adj1 <- adj %>% 
  mutate(risk_group = fitsurv[["where"]])
km <- survfit(surv_model ~ risk_group, data = adj1)
ggsurvplot(km, data = adj1,
           title = "Recurrence Analysis",
           font.main = c(20, "bold", "black"),
           font.x = c(18, "bold", "black"),
           font.y = c(18, "bold", "black"),
           font.legend = c(16, "black"),
           font.tickslab = c(16, "bold", "black"),
           size = 1.5,
           xlab = "Time in months",
           legend = "top",
           legend.title = "",
           pval = TRUE,
           conf.int = FALSE,
           # Censor
           censor = TRUE
) + guides(colour = guide_legend(ncol = 1))
```
</div>

<div class = "col-md-6">
```{r}
rpart.plot(fitsurv_neo)

neo1 <- neo %>% 
  mutate(risk_group = fitsurv_neo[["where"]])
km <- survfit(Surv(neo1$recurrence_time, neo1$rec_event) ~ risk_group, data = neo1)
ggsurvplot(km, data = neo1,
           title = "Recurrence Analysis",
           font.main = c(20, "bold", "black"),
           font.x = c(18, "bold", "black"),
           font.y = c(18, "bold", "black"),
           font.legend = c(16, "black"),
           font.tickslab = c(16, "bold", "black"),
           size = 1.5,
           xlab = "Time in months",
           legend = "top",
           legend.title = "",
           pval = TRUE,
           conf.int = FALSE,
           # Censor
           censor = TRUE
) + guides(colour = guide_legend(ncol = 1))
```
</div>
</div>

<br>

### OR predict leaf

```{r}
leaf_rpart <- rpart(risk_group ~ f65flatness + f80com_x_pxl + f85com_z_mm, 
                 data = adj1, 
                 # method = "exp", 
                 control = rpart.control( cp= 0.03, 
                                          #minsplit = , minbucket = , maxdepth = , 
                                          xval = 10))
rpart.plot(leaf_rpart)

library(partykit)
neo2 <- neo %>% 
  mutate(risk_group2 = predict(as.party(leaf_rpart), newdata = neo))
```

<div class = "row">
<div class = "col-md-6">
```{r}
# Plots
km <- survfit(surv_model ~ risk_group, data = adj1)
ggsurvplot(km, data = adj1,
           title = "Recurrence Analysis",
           font.main = c(20, "bold", "black"),
           font.x = c(18, "bold", "black"),
           font.y = c(18, "bold", "black"),
           font.legend = c(16, "black"),
           font.tickslab = c(16, "bold", "black"),
           size = 1.5,
           xlab = "Time in months",
           legend = "top",
           legend.title = "",
           pval = TRUE,
           conf.int = FALSE,
           # Censor
           censor = TRUE
) + guides(colour = guide_legend(ncol = 1))
```
</div>

<div class = "col-md-6">
```{r}
km <- survfit(Surv(neo2$recurrence_time, neo2$rec_event) ~ risk_group2, data = neo2)
ggsurvplot(km, data = neo2,
           title = "Recurrence Analysis",
           font.main = c(20, "bold", "black"),
           font.x = c(18, "bold", "black"),
           font.y = c(18, "bold", "black"),
           font.legend = c(16, "black"),
           font.tickslab = c(16, "bold", "black"),
           size = 1.5,
           xlab = "Time in months",
           legend = "top",
           legend.title = "",
           pval = TRUE,
           conf.int = FALSE,
           # Censor
           censor = TRUE
) + guides(colour = guide_legend(ncol = 1))
```
</div>
</div>

<br>

# C index
```{r}
library(survcomp)
a <- concordance.index(x=predict(fitsurv), surv.time = adj$recurrence_time, surv.event = adj$rec_event,
                            method = "noether", na.rm = TRUE)
b <- concordance.index(x=predict(fitsurv, newdata = neo), surv.time = neo$recurrence_time, surv.event = neo$rec_event,
                            method = "noether", na.rm = TRUE)
# tibble(training_adjuvant = c(a$c.index, a$se),
#        testing_neoadj = c(b$c.index, b$se)) %>% kableExtra::kable()
```


<table>
 <thead>
  <tr>
   <th style="text-align:center;"> measurement </th>
   <th style="text-align:center;"> training_adjuvant </th>
   <th style="text-align:center;"> testing_neoadj </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:center;"> C index </td>
   <td style="text-align:right;"> 0.687 </td>
   <td style="text-align:right;">   0.531   </td>
  </tr>
  <tr>
   <td style="text-align:center;"> se </td>
   <td style="text-align:right;"> 0.034 </td>
   <td style="text-align:right;"> 0.049 </td>
  </tr>
</tbody>
</table>

<br>

```{r}
# Need to use mlr3 as pec and other packages don't calculate c index for rpart
library(mlr3verse)
library(mlr3proba)

mldata1 <- mldata %>% #drop_na() %>% 
  select(-treatment_type)
# mldata1$status = (mldata1$status == 2L)
task <- TaskSurv$new("mldata1",
                    backend = mldata1, time = "recurrence_time",
                    event = "rec_event")
# task_penguins = task
# task_penguins$select(c("body_mass", "flipper_length")) # keep only these features
# task_penguins$filter(1:3) # keep only these rows
# task$head()

learner = lrn("surv.rpart", cp = 0.03)
# train_set = sample(task$nrow, 0.8 * task$nrow)
# test_set = setdiff(seq_len(task$nrow), train_set)

# learner$train(task, row_ids = train_set)
# print(learner$model)
# rattle::fancyRpartPlot(learner$model)
# 
# prediction = learner$predict(task, row_ids = test_set)
# 
# head(as.data.table(prediction)) # show first six predictions
# 
# task$truth()
# task$times()
# task$status()
# task$unique_times()
# task$unique_event_times()
# task$risk_set(time = 10)
# 
# # library(GGally)
# # autoplot(task)
# 
# measure = msr("surv.cindex") # Use crank prediction = Continuous risk ranking
# print(measure)
# prediction$score(measure)
# 
# prediction$print(measure)

########################################################
resampling = rsmp("custom")
resampling$instantiate(task,
                       train = list(which(mldata$treatment_type == "Upfront Surgery")),
                       test = list(which(mldata$treatment_type == "Upfront Neoadjuvant"))
)

library(mlr3learners)
design = benchmark_grid(
  tasks =  task,
  learners = lrns(c("surv.coxph", "surv.rpart", "surv.ranger"),
                  predict_sets = c("train", "test")),
  resamplings = resampling
)

bmr  <-  benchmark(design)
measures = list(
  msr("surv.cindex", predict_sets = "train", id = "cindex_adj"),
  msr("surv.cindex", predict_sets = "test", id = "cindex_neo")
)

tab = bmr$aggregate(measures)
print(tab[,4:8])
library(mlr3viz)
# autoplot(bmr) + ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1))
tab %>% group_by(learner_id) %>% 
  pivot_longer(cols = c(cindex_adj, cindex_neo), names_to = "cindex", values_to = "value") %>% 
  ggplot(aes(x= learner_id, y = value, color= cindex))+
  geom_point()+
  labs(x="", y="C index value")+
  theme_minimal()
```

# But C-index may not be best to look at survival tree
Unfortunately, most packages don't compute C-index with rpart model so I will show that with other model. What do you think?
```{r, warning=TRUE}
fit1 <- coxph(Surv(recurrence_time, rec_event) ~ f65flatness + f80com_x_pxl + f85com_z_mm, data=adj, 
              x=TRUE,y=TRUE)
fit2 <- coxph(Surv(recurrence_time, rec_event) ~ f65flatness + f80com_x_pxl + f85com_z_mm, data=neo, 
              x=TRUE,y=TRUE)
library(pec)
a <- cindex(list("adj"=fit1,"neo"=fit2),
                 formula=Surv(recurrence_time, rec_event)~ f65flatness + f80com_x_pxl + f85com_z_mm,
                 data=neo, eval.times=seq(1,80,1)) 
print(a)
plot(a)
```

# AUC in case
```{r}
# Use rms
# fitsurv #<- rpart(Surv(recurrence_time, rec_event) ~ . , data = neo)
library("ROCR")
pred_adj = data.frame(predict(fitsurv, newdata=adj,type = "matrix"))[,1]
# Out_neo=data.frame()
pred_adj=cbind(adj,pred_adj)
pred_neo = data.frame(predict(fitsurv, newdata=neo,type = "matrix"))[,1]
pred_neo=cbind(neo,pred_neo)

#ROC
library(survivalROC)
roc_adj=survivalROC(Stime=pred_adj$recurrence_time, 
                    status=pred_adj$rec_event, 
                    marker = pred_adj$pred_adj, 
                    predict.time =365, # For a 1 year survival
                    method="KM")
roc_adj$AUC
roc_neo=survivalROC(Stime=pred_neo$recurrence_time, 
                    status=pred_neo$rec_event, 
                    marker = pred_neo$pred_neo, 
                    predict.time =365, # For a 1 year survival
                    method="KM")
roc_neo$AUC

roc_adj=survivalROC(Stime=pred_adj$recurrence_time, 
                    status=pred_adj$rec_event, 
                    marker = pred_adj$pred_adj,
                    predict.time =c(10, 20, 40, 60, 80), 
                    method="KM")
roc_adj$AUC
roc_neo=survivalROC(Stime=pred_neo$recurrence_time, 
                    status=pred_neo$rec_event, 
                    marker = pred_neo$pred_neo,
                    predict.time =c(10, 20, 40, 60, 80), 
                    method="KM")
roc_neo$AUC

ADJ <- tibble(true_positive_rate = roc_adj$TP,
              false_positive_rate = roc_adj$FP)
NEO <- tibble(true_positive_rate = roc_neo$TP,
              false_positive_rate = roc_neo$FP)
NEO %>% 
  ggplot(aes(x= false_positive_rate, y= true_positive_rate))+
  geom_line(color = "blue")+
  geom_line(data = ADJ, color = "red")+
  geom_abline(intercept = 0, slope = 1, linetype = 3)+
  theme_minimal()
```







# Should I 




```{r}
library(riskRegression)
# fitsurv# <- rpart(Surv(recurrence_time, rec_event)~ f65flatness + f80com_x_pxl + f85com_z_mm, data = train_adj , method = "exp")
# fitsurv_neo# <- rpart(Surv(recurrence_time, rec_event)~ f65flatness + f80com_x_pxl + f85com_z_mm, data = neo , method = "exp")

xx1 <- Score(list("adj" = fitsurv),
            formula=Surv(recurrence_time, rec_event) ~ f65flatness + f80com_x_pxl + f85com_z_mm,
            data=adj, 
            metrics="auc", 
            null.model=FALSE, times=seq(5,80,5))

xx2 <- Score(list("neo" = fitsurv),
            formula=Surv(recurrence_time, rec_event) ~ f65flatness + f80com_x_pxl + f85com_z_mm,
            data=neo, 
            metrics="auc", 
            null.model=FALSE, times=seq(5,80,5))

xx1$AUC$score %>% bind_rows(xx2$AUC$score) %>% 
  ggplot(aes(x= times, y= AUC, color= model))+
  geom_line()+
  geom_errorbar(aes(ymin = AUC-se, ymax = AUC+se),
                alpha= 0.3, width = 0.2)+
  theme_minimal()

t.test(xx1$AUC$score$AUC, xx2$AUC$score$AUC)


library(randomForestSRC)
fit_cox <- coxph(Surv(recurrence_time, rec_event)
               ~ f65flatness + f80com_x_pxl + f85com_z_mm, 
              data = adj, 
              na.action=na.omit, x = TRUE)
fit_flex <- flexsurv::flexsurvreg(Surv(recurrence_time, rec_event)
                               ~ f65flatness + f80com_x_pxl + f85com_z_mm, 
                              data = adj, 
                              dist = "weibull" )
fit_rg <- rfsrc(Surv(recurrence_time, rec_event) ~ 
              f65flatness + f80com_x_pxl + f85com_z_mm, 
            data=adj)

xx <- Score(list("Cox" = fit_cox,
                 "rg" = fit_rg,
                 "flexsurv" = fit_flex,
                 "rpart" = fitsurv), 
            formula=Surv(recurrence_time, rec_event) ~ f65flatness + f80com_x_pxl + f85com_z_mm,
            data = neo, 
            metrics = "auc", 
            null.model = FALSE, 
            times = seq(5,80,5))
xx$AUC$score
xx$AUC$score %>% 
  ggplot(aes(x= times, y= AUC, color= model))+
  geom_line()+
  geom_errorbar(aes(ymin = AUC-se, ymax = AUC+se),
                alpha= 0.3, width = 0.2)
```

### Cox still better











```{r}
# library(partykit)
# party_fit <- as.party(fitsurv)
# predict(party_fit, newdata = adj, type = "prob")[1]
# predict(party_fit, newdata = neo, type = "prob")[[1]]
# 
# # tree2 = neo_fit
# fitsurv[["frame"]]$var
# fitsurv[["where"]]
# # adj_fit$frame$yval = as.numeric(rownames(adj_fit$frame))
# # neo_fit$frame$yval = as.numeric(rownames(neo_fit$frame))
# 
# ############################################################################################# AUC
# #Get the survival function value of each sample
# Surv_value = data.frame(predict(fitsurv, newdata=adj,type = "matrix"))[,1]
# Out_adj=data.frame()
# Out_adj=cbind(adj,Surv_value)
# 
# Surv_value = data.frame(predict(fitsurv, newdata=neo,type = "matrix"))[,1]
# Out_neo=data.frame()
# Out_neo=cbind(neo,Surv_value)
# 
# library(survivalROC)
# roc_adj=survivalROC(Stime=Out_adj$recurrence_time, status=Out_adj$rec_event, 
#                     marker = Out_adj$Surv_value, predict.time =100, method="KM")
# roc_neo=survivalROC(Stime=Out_neo$recurrence_time, status=Out_neo$rec_event, 
#                     marker = Out_neo$Surv_value, predict.time =100, method="KM")
# 
# roc_adj$AUC #Get the AUC of ROC plot
# roc_neo$AUC
# 
# wilcox.test(roc_neo$AUC, roc_adj$AUC)
# 
# ADJ <- tibble(true_positive_rate = roc_adj$TP,
#               false_positive_rate = roc_adj$FP)
# NEO <- tibble(true_positive_rate = roc_neo$TP,
#               false_positive_rate = roc_neo$FP)
# NEO %>% 
#   ggplot(aes(x= false_positive_rate, y= true_positive_rate))+
#   geom_line(color = "blue")+
#   geom_line(data = ADJ, color = "red")+
#   geom_abline(intercept = 0, slope = 1, linetype = 3)+
#   theme_minimal()
# 
# ks.test(NEO$false_positive_rate,ADJ$false_positive_rate)
# t.test(NEO$false_positive_rate,ADJ$false_positive_rate)
# 
# # library(pec) # 
# # pec::cindex(list("adj"=roc_adj,"neo"=roc_neo),
# #             formula=Surv(recurrence_time, rec_event)~ f65flatness + f80com_x_pxl + f85com_z_mm,
# #             data=mldata) 
# 
# # library(pROC)
# # roc.test(roc_adj, roc_neo, method="sensitivity")
# 
# library(ROCR)
# # fitsurv  <- rpart(ifOperStatus ~ .,data=train,method = "class",parms = list(prior = c(0.3, 0.7)))
# #parms = list(prior = c(0.5, 0.5)
# #Confusion matrix
# rpartpred <- predict(fitsurv,neo)
# confusionMatrix(rpartpred,val$ifOperStatus)
# prp(fitsurv, faclen = 0, cex = 0.8, extra = 1)
# tot_count <- function(x, labs, digits, varlen)
# {paste(labs, "\n\nn =", x$frame$n)}
# ## Decision Tree
# prp(fitsurv, faclen = 0, cex = 0.8, node.fun=tot_count)
# printcp(fitsurv)
# bestcp <- fitsurv$cptable[which.min(fitsurv$cptable[,"xerror"]),"CP"]
# #Pruning & classification matrix of Pruning
# pruned <- prune(fitsurv, cp = bestcp)
# prp(pruned, faclen = 0, cex = 0.8, extra = 1)
# predictions <- predict(pruned, neo)
# confusionMatrix(predictions,val$ifOperStatus)
# # bestcp <- fitsurv$cptable[which.min(fitsurv$cptable[,"xerror"]),"CP"]
# # #Pruning & classification matrix of Pruning
# fitsurv1 <- prune(fitsurv, cp = bestcp)
# prp(fitsurv1, faclen = 0, cex = 0.8, extra = 1)
# 
# predictions <- predict(fitsurv1, neo)
# confusionMatrix(predictions,val$ifOperStatus)
# val1 = predict(fitsurv1, neo, type = "prob")
# pred_val <-prediction(val1[,2],val$ifOperStatus)
# perf_val <- performance(pred_val,"auc")
# perf_val

```


### Split Adjuvant

I think that training and testing on the same data give bias results so it is better to train on a split data set of **Upfront surgery** then test on either split testing **Upfront surgery** and testing **Upfront Chemo** and compare statistics.


# Splitting the data

The data is split in 3/4 for training and testing for better robustness.  
A strata is applied to the split function to balance has_the_patient_recurred in both sets.  
```{r}
set.seed(5678)
adj_split <- initial_split(adj, prop = 3/4)
# Create training and testing datasets:
train_adj <- training(adj_split)
test_adj  <- testing(adj_split)
```

```{r}

```












```{r}
set.seed(1234)
surv_model <- Surv(train_adj$recurrence_time, train_adj$rec_event)
# surv_model # surv_model is dependent variable
fitsurv <- rpart::rpart(surv_model ~ f65flatness + f80com_x_pxl + f85com_z_mm, data = train_adj, method = "exp")
# fitsurv
# plot(fitsurv)
# text(fitsurv, use.n = TRUE, cex = 0.75, all = TRUE)
# rpart.plot(fitsurv)
# fancyRpartPlot(fitsurv)
# path.rpart(fitsurv, node =2)

# Look at CP  
# plotcp(fitsurv)
printcp(fitsurv)

# Update formula 
set.seed(1234)
fitsurv <- rpart(surv_model ~ f65flatness + f80com_x_pxl + f85com_z_mm, 
                 data = train_adj, 
                 method = "exp", 
                 control = rpart.control(cp= 0.035, 
                                         xval = 10))
# fitsurv
rpart.plot(fitsurv)
# fancyRpartPlot(fitsurv)

fitsurv_neo <- rpart(Surv(neo$recurrence_time, neo$rec_event) ~ f65flatness + f80com_x_pxl + f85com_z_mm, 
                 data = neo, 
                 method = "exp", 
                 control = rpart.control( cp= 0.035, 
                                          xval = 10))
rpart.plot(fitsurv_neo)

train_adj1 <- train_adj %>% 
  mutate(risk_group = fitsurv[["where"]])
km <- survfit(surv_model ~ risk_group, data = train_adj1)
ggsurvplot(km, data = train_adj1,
           title = "Recurrence Analysis",
           font.main = c(20, "bold", "black"),
           font.x = c(18, "bold", "black"),
           font.y = c(18, "bold", "black"),
           font.legend = c(16, "black"),
           font.tickslab = c(16, "bold", "black"),
           size = 1.5,
           xlab = "Time in months",
           legend = "top",
           legend.title = "",
           pval = TRUE,
           conf.int = FALSE,
           # Censor
           censor = TRUE
) + guides(colour = guide_legend(ncol = 1))

neo1 <- neo %>% 
  mutate(risk_group = fitsurv_neo[["where"]])
km <- survfit(Surv(neo1$recurrence_time, neo1$rec_event) ~ risk_group, data = neo1)
ggsurvplot(km, data = neo1,
           title = "Recurrence Analysis",
           font.main = c(20, "bold", "black"),
           font.x = c(18, "bold", "black"),
           font.y = c(18, "bold", "black"),
           font.legend = c(16, "black"),
           font.tickslab = c(16, "bold", "black"),
           size = 1.5,
           xlab = "Time in months",
           legend = "top",
           legend.title = "",
           pval = TRUE,
           conf.int = FALSE,
           # Censor
           censor = TRUE
) + guides(colour = guide_legend(ncol = 1))
```

### OR predict leaf
```{r}
leaf_rpart <- rpart(risk_group ~ f65flatness + f80com_x_pxl + f85com_z_mm, 
                 data = train_adj1, 
                 # method = "exp", 
                 control = rpart.control( cp= 0.035, 
                                          #minsplit = , minbucket = , maxdepth = , 
                                          xval = 10))
rpart.plot(leaf_rpart)

library(partykit)
neo2 <- neo %>% 
  mutate(risk_group2 = predict(as.party(leaf_rpart), newdata = neo))

# Plots
km <- survfit(surv_model ~ risk_group, data = train_adj1)
ggsurvplot(km, data = train_adj1,
           title = "Recurrence Analysis",
           font.main = c(20, "bold", "black"),
           font.x = c(18, "bold", "black"),
           font.y = c(18, "bold", "black"),
           font.legend = c(16, "black"),
           font.tickslab = c(16, "bold", "black"),
           size = 1.5,
           xlab = "Time in months",
           legend = "top",
           legend.title = "",
           pval = TRUE,
           conf.int = FALSE,
           # Censor
           censor = TRUE
) + guides(colour = guide_legend(ncol = 1))

km <- survfit(Surv(neo2$recurrence_time, neo2$rec_event) ~ risk_group2, data = neo2)
ggsurvplot(km, data = neo2,
           title = "Recurrence Analysis",
           font.main = c(20, "bold", "black"),
           font.x = c(18, "bold", "black"),
           font.y = c(18, "bold", "black"),
           font.legend = c(16, "black"),
           font.tickslab = c(16, "bold", "black"),
           size = 1.5,
           xlab = "Time in months",
           legend = "top",
           legend.title = "",
           pval = TRUE,
           conf.int = FALSE,
           # Censor
           censor = TRUE
) + guides(colour = guide_legend(ncol = 1))
```

# C index
```{r}
library(survcomp)
a <- concordance.index(x=predict(fitsurv), surv.time = train_adj$recurrence_time, surv.event = train_adj$rec_event,
                            method = "noether", na.rm = TRUE)
b <- concordance.index(x=predict(fitsurv, newdata = neo), surv.time = neo$recurrence_time, surv.event = neo$rec_event,
                            method = "noether", na.rm = TRUE)
```


<table>
 <thead>
  <tr>
   <th style="text-align:center;"> measurement </th>
   <th style="text-align:center;"> training_train_adjuvant </th>
   <th style="text-align:center;"> testing_neoadj </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:center;"> C index </td>
   <td style="text-align:right;"> 0.687 </td>
   <td style="text-align:right;">   0.531   </td>
  </tr>
  <tr>
   <td style="text-align:center;"> se </td>
   <td style="text-align:right;"> 0.034 </td>
   <td style="text-align:right;"> 0.049 </td>
  </tr>
</tbody>
</table>

<br>

```{r}
# Need to use mlr3 as pec and other packages don't calculate c index for rpart
# library(mlr3verse)
# library(mlr3proba)

mldata <- bind_rows(train_adj %>% 
                       mutate(data = "train_adj"),
                     test_adj %>% 
                       mutate(data = "test_adj"),
                     neo %>% 
                       mutate(data = "neo"),
                     )
mldata1 <- mldata %>% 
  select(-data)
# mldata1$status = (mldata1$status == 2L)
task <- TaskSurv$new("mldata1",
                    backend = mldata1, time = "recurrence_time",
                    event = "rec_event")
# task_penguins = task
# task_penguins$select(c("body_mass", "flipper_length")) # keep only these features
# task_penguins$filter(1:3) # keep only these rows
# task$head()

learner = lrn("surv.rpart", cp = 0.03)

# learner$model

# train_set = sample(task$nrow, 0.8 * task$nrow)
# test_set = setdiff(seq_len(task$nrow), train_set)

# learner$train(task, row_ids = train_set)
# print(learner$model)
# rattle::fancyRpartPlot(learner$model)
# 
# prediction = learner$predict(task, row_ids = test_set)
# 
# head(as.data.table(prediction)) # show first six predictions
# 
# task$truth()
# task$times()
# task$status()
# task$unique_times()
# task$unique_event_times()
# task$risk_set(time = 10)
# 
# # library(GGally)
# # autoplot(task)
# 
# measure = msr("surv.cindex") # Use crank prediction = Continuous risk ranking
# print(measure)
# prediction$score(measure)
# 
# prediction$print(measure)

########################################################
resampling = rsmp("custom")
resampling$instantiate(task,
                       train = list(which(mldata$data == "train_adj")),
                       test = list(which(mldata$data == "test_adj"))
)

# library(mlr3learners)
design = benchmark_grid(
  tasks =  task,
  learners = lrns(c("surv.coxph", "surv.rpart", "surv.ranger"),
                  predict_sets = c("train", "test")),
  resamplings = resampling
)

bmr = benchmark(design)
measures = list(
  msr("surv.cindex", predict_sets = "train", id = "cindex_train_adj"),
  msr("surv.cindex", predict_sets = "test", id = "cindex_test_adj")
)

tab1 = bmr$aggregate(measures)
print(tab1[,4:8])

tab1 %>% group_by(learner_id) %>% 
  pivot_longer(cols = c(cindex_train_adj, cindex_test_adj), names_to = "cindex", values_to = "value") %>% 
  ggplot(aes(x= learner_id, y = value, color= cindex))+
  geom_point()+
  labs(x="", y="C index value")+
  theme_minimal()
########
resampling = rsmp("custom")
resampling$instantiate(task,
                       train = list(which(mldata$data == "train_adj")),
                       test = list(which(mldata$data == "neo"))
)

design = benchmark_grid(
  tasks =  task,
  learners = lrns(c("surv.coxph", "surv.rpart", "surv.ranger"),
                  predict_sets = c("train", "test")),
  resamplings = resampling
)

bmr = benchmark(design)
measures = list(
  msr("surv.cindex", predict_sets = "train", id = "cindex_train_adj"),
  msr("surv.cindex", predict_sets = "test", id = "cindex_neo")
)

tab2 = bmr$aggregate(measures)
print(tab2[,4:8])
tab2 %>% group_by(learner_id) %>% 
  pivot_longer(cols = c(cindex_train_adj, cindex_neo), names_to = "cindex", values_to = "value") %>% 
  bind_rows(., tab1 %>% pivot_longer(cols = cindex_test_adj, names_to = "cindex", values_to = "value")) %>% 
  ggplot(aes(x= learner_id, y = value, color= cindex))+
  geom_point()+
  labs(x="", y="C index value")+
  theme_minimal()
```

# AUC in case
```{r}
# Use rms
# fitsurv #<- rpart(Surv(recurrence_time, rec_event) ~ . , data = neo)
# library("ROCR")
pred_train_adj = data.frame(predict(fitsurv, newdata=train_adj,type = "matrix"))[,1]
# Out_neo=data.frame()
pred_train_adj=cbind(train_adj,pred_train_adj)
pred_test_adj = data.frame(predict(fitsurv, newdata=test_adj,type = "matrix"))[,1]
pred_test_adj=cbind(test_adj,pred_test_adj)
pred_neo = data.frame(predict(fitsurv, newdata=neo,type = "matrix"))[,1]
pred_neo=cbind(neo,pred_neo)

#ROC
# library(survivalROC)
roc_train_adj=survivalROC(Stime=pred_train_adj$recurrence_time, 
                    status=pred_train_adj$rec_event, 
                    marker = pred_train_adj$pred_train_adj, 
                    predict.time =365, # For a 1 year survival
                    method="KM")
roc_train_adj$AUC
roc_test_adj=survivalROC(Stime=pred_test_adj$recurrence_time, 
                    status=pred_test_adj$rec_event, 
                    marker = pred_test_adj$pred_test_adj, 
                    predict.time =365, # For a 1 year survival
                    method="KM")
roc_test_adj$AUC
roc_neo=survivalROC(Stime=pred_neo$recurrence_time, 
                    status=pred_neo$rec_event, 
                    marker = pred_neo$pred_neo, 
                    predict.time =365, # For a 1 year survival
                    method="KM")
roc_neo$AUC

roc_train_adj=survivalROC(Stime=pred_train_adj$recurrence_time, 
                    status=pred_train_adj$rec_event, 
                    marker = pred_train_adj$pred_train_adj,
                    predict.time =c(10, 20, 40, 60, 80), 
                    method="KM")
roc_train_adj$AUC
roc_test_adj=survivalROC(Stime=pred_test_adj$recurrence_time, 
                    status=pred_test_adj$rec_event, 
                    marker = pred_test_adj$pred_test_adj,
                    predict.time =c(10, 20, 40, 60, 80), 
                    method="KM")
roc_test_adj$AUC
roc_neo=survivalROC(Stime=pred_neo$recurrence_time, 
                    status=pred_neo$rec_event, 
                    marker = pred_neo$pred_neo,
                    predict.time =c(10, 20, 40, 60, 80), 
                    method="KM")
roc_neo$AUC

train_ADJ <- tibble(true_positive_rate = roc_train_adj$TP,
              false_positive_rate = roc_train_adj$FP)
test_ADJ <- tibble(true_positive_rate = roc_test_adj$TP,
              false_positive_rate = roc_test_adj$FP)
NEO <- tibble(true_positive_rate = roc_neo$TP,
              false_positive_rate = roc_neo$FP)
NEO %>% 
  ggplot(aes(x= false_positive_rate, y= true_positive_rate))+
  geom_line(color = "blue")+
  geom_line(data = train_ADJ, color = "red")+
  geom_line(data = test_ADJ, color = "green")+
  geom_abline(intercept = 0, slope = 1, linetype = 3)+
  theme_minimal()
```











```{r}
library(riskRegression)
fitsurv# <- rpart(Surv(recurrence_time, rec_event)~ f65flatness + f80com_x_pxl + f85com_z_mm, data = train_adj , method = "exp")
# fitsurv_neo# <- rpart(Surv(recurrence_time, rec_event)~ f65flatness + f80com_x_pxl + f85com_z_mm, data = neo , method = "exp")

xx1 <- Score(list("train_adj" = fitsurv),
            formula=Surv(recurrence_time, rec_event) ~ f65flatness + f80com_x_pxl + f85com_z_mm,
            data=train_adj, 
            metrics="auc", 
            null.model=FALSE, times=seq(5,80,5))
xx2 <- Score(list("test_adj" = fitsurv),
            formula=Surv(recurrence_time, rec_event) ~ f65flatness + f80com_x_pxl + f85com_z_mm,
            data=test_adj, 
            metrics="auc", 
            null.model=FALSE, times=seq(5,80,5))
xx3 <- Score(list("neo" = fitsurv),
            formula=Surv(recurrence_time, rec_event) ~ f65flatness + f80com_x_pxl + f85com_z_mm,
            data=neo, 
            metrics="auc", 
            null.model=FALSE, times=seq(5,80,5))

xx1$AUC$score %>% bind_rows(xx2$AUC$score, xx3$AUC$score) %>% 
  ggplot(aes(x= times, y= AUC, color= model))+
  geom_line()+
  geom_errorbar(aes(ymin = AUC-se, ymax = AUC+se),
                alpha= 0.3, width = 0.2)

t.test(xx2$AUC$score$AUC, xx3$AUC$score$AUC)


library(randomForestSRC)
fit_cox <- coxph(Surv(recurrence_time, rec_event)
               ~ f65flatness + f80com_x_pxl + f85com_z_mm, 
              data = train_adj, 
              na.action=na.omit, x = TRUE)
fit_flex <- flexsurv::flexsurvreg(Surv(recurrence_time, rec_event)
                               ~ f65flatness + f80com_x_pxl + f85com_z_mm, 
                              data = train_adj, 
                              dist = "weibull" )
fit_rg <- rfsrc(Surv(recurrence_time, rec_event) ~ 
              f65flatness + f80com_x_pxl + f85com_z_mm, 
            data=train_adj)

xx <- Score(list("Cox" = fit_cox,
                 "rg" = fit_rg,
                 "flexsurv" = fit_flex,
                 "rpart" = fitsurv), 
            formula=Surv(recurrence_time, rec_event) ~ f65flatness + f80com_x_pxl + f85com_z_mm,
            data = neo, 
            metrics = "auc", 
            null.model = FALSE, 
            times = seq(5,80,5))
# xx$AUC$score
xx$AUC$score %>% 
  ggplot(aes(x= times, y= AUC, color= model))+
  geom_line()+
  geom_errorbar(aes(ymin = AUC-se, ymax = AUC+se),
                alpha= 0.3, width = 0.2)
```

### Cox and flexsurv still better


# Compare performance with binary prediction


```{r}
rf_results <- read_rds(paste0(here::here(), "/rf_results.rds"))
xgboost_results <- read_rds(paste0(here::here(), "/xgboost_results.rds"))
tree_results <- read_rds(paste0(here::here(), "/tree_results.rds"))
kknn_results <- read_rds(paste0(here::here(), "/kknn_results.rds"))
glmnet_results <- read_rds(paste0(here::here(), "/glmnet_results.rds"))
```





<div class = "row">
<div class = "col-md-6">
```{r}
rf_results %>% # Compare both models
  collect_predictions() %>% 
  mutate(model = "rf") %>% 
  bind_rows(glmnet_results %>% 
              collect_predictions() %>% 
              mutate(model = "glmet")) %>% 
  bind_rows(xgboost_results %>% 
              collect_predictions() %>% 
              mutate(model = "xgboost")) %>% 
  bind_rows(tree_results %>% 
              collect_predictions() %>% 
              mutate(model = "tree")) %>% 
  bind_rows(kknn_results %>% 
              collect_predictions() %>% 
              mutate(model = "kknn")) %>% 
  group_by(model) %>% 
  roc_curve(has_the_patient_recurred, .pred_Recurrence) %>% 
  autoplot()
```
</div>

<div class = "col-md-6">
```{r}
NEO %>% 
  ggplot(aes(x= false_positive_rate, y= true_positive_rate))+
  geom_line(color = "blue")+
  geom_line(data = train_ADJ, color = "red")+
  geom_line(data = test_ADJ, color = "green")+
  geom_abline(intercept = 0, slope = 1, linetype = 3)+
  theme_minimal()
```
</div>
</div>

```{r}
# rf_results %>% # Compare both models
#   collect_predictions() %>% 
#   mutate(model = "rf") %>% 
#   bind_rows(glmnet_results %>% 
#               collect_predictions() %>% 
#               mutate(model = "glmet")) %>% 
#   bind_rows(xgboost_results %>% 
#               collect_predictions() %>% 
#               mutate(model = "xgboost")) %>% 
#   bind_rows(tree_results %>% 
#               collect_predictions() %>% 
#               mutate(model = "tree")) %>% 
#   bind_rows(kknn_results %>% 
#               collect_predictions() %>% 
#               mutate(model = "kknn")) %>% 
#   group_by(model) %>% 
#   roc_curve(has_the_patient_recurred, .pred_Recurrence) %>% 
#   ggplot(aes(x= 1-specificity, y= sensitivity, color = model))+
#   geom_line()


# library(partykit)
# party_fit <- as.party(fitsurv)
# predict(party_fit, newdata = adj, type = "prob")[1]
# predict(party_fit, newdata = neo, type = "prob")[[1]]
# 
# # tree2 = neo_fit
# fitsurv[["frame"]]$var
# fitsurv[["where"]]
# # adj_fit$frame$yval = as.numeric(rownames(adj_fit$frame))
# # neo_fit$frame$yval = as.numeric(rownames(neo_fit$frame))
# 
# ############################################################################################# AUC
# #Get the survival function value of each sample
# Surv_value = data.frame(predict(fitsurv, newdata=adj,type = "matrix"))[,1]
# Out_adj=data.frame()
# Out_adj=cbind(adj,Surv_value)
# 
# Surv_value = data.frame(predict(fitsurv, newdata=neo,type = "matrix"))[,1]
# Out_neo=data.frame()
# Out_neo=cbind(neo,Surv_value)
# 
# library(survivalROC)
# roc_adj=survivalROC(Stime=Out_adj$recurrence_time, status=Out_adj$rec_event, 
#                     marker = Out_adj$Surv_value, predict.time =100, method="KM")
# roc_neo=survivalROC(Stime=Out_neo$recurrence_time, status=Out_neo$rec_event, 
#                     marker = Out_neo$Surv_value, predict.time =100, method="KM")
# 
# roc_adj$AUC #Get the AUC of ROC plot
# roc_neo$AUC
# 
# wilcox.test(roc_neo$AUC, roc_adj$AUC)
# 
# ADJ <- tibble(true_positive_rate = roc_adj$TP,
#               false_positive_rate = roc_adj$FP)
# NEO <- tibble(true_positive_rate = roc_neo$TP,
#               false_positive_rate = roc_neo$FP)
# NEO %>% 
#   ggplot(aes(x= false_positive_rate, y= true_positive_rate))+
#   geom_line(color = "blue")+
#   geom_line(data = ADJ, color = "red")+
#   geom_abline(intercept = 0, slope = 1, linetype = 3)+
#   theme_minimal()
# 
# ks.test(NEO$false_positive_rate,ADJ$false_positive_rate)
# t.test(NEO$false_positive_rate,ADJ$false_positive_rate)
# 
# # library(pec) # 
# # pec::cindex(list("adj"=roc_adj,"neo"=roc_neo),
# #             formula=Surv(recurrence_time, rec_event)~ f65flatness + f80com_x_pxl + f85com_z_mm,
# #             data=mldata) 
# 
# # library(pROC)
# # roc.test(roc_adj, roc_neo, method="sensitivity")
# 
# library(ROCR)
# # fitsurv  <- rpart(ifOperStatus ~ .,data=train,method = "class",parms = list(prior = c(0.3, 0.7)))
# #parms = list(prior = c(0.5, 0.5)
# #Confusion matrix
# rpartpred <- predict(fitsurv,neo)
# confusionMatrix(rpartpred,val$ifOperStatus)
# prp(fitsurv, faclen = 0, cex = 0.8, extra = 1)
# tot_count <- function(x, labs, digits, varlen)
# {paste(labs, "\n\nn =", x$frame$n)}
# ## Decision Tree
# prp(fitsurv, faclen = 0, cex = 0.8, node.fun=tot_count)
# printcp(fitsurv)
# bestcp <- fitsurv$cptable[which.min(fitsurv$cptable[,"xerror"]),"CP"]
# #Pruning & classification matrix of Pruning
# pruned <- prune(fitsurv, cp = bestcp)
# prp(pruned, faclen = 0, cex = 0.8, extra = 1)
# predictions <- predict(pruned, neo)
# confusionMatrix(predictions,val$ifOperStatus)
# # bestcp <- fitsurv$cptable[which.min(fitsurv$cptable[,"xerror"]),"CP"]
# # #Pruning & classification matrix of Pruning
# fitsurv1 <- prune(fitsurv, cp = bestcp)
# prp(fitsurv1, faclen = 0, cex = 0.8, extra = 1)
# 
# predictions <- predict(fitsurv1, neo)
# confusionMatrix(predictions,val$ifOperStatus)
# val1 = predict(fitsurv1, neo, type = "prob")
# pred_val <-prediction(val1[,2],val$ifOperStatus)
# perf_val <- performance(pred_val,"auc")
# perf_val

```












